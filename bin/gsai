#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 cvlc12

set -e

trap 'echo; exit' SIGINT
trap 'clean' EXIT

# Configuration
download_page="https://archlinux.org/download/"

# Clean temporary files before exiting
backup_iso() {

    local source=${1}
    local filename
    filename="$(basename "$source")"

    if [[ -n "$output_dir" ]]; then
        dest="${output_dir}/${filename}"
    else
        ask_path "back up ISO" dest "${local_dir:-${HOME}}/${filename}"
        [[ -n "$dest" ]] || err "No path provided"
    fi

    # TODO: don't overwrite existing file, deal with existing files
    if mv "$source" "${dest:?}" &>/dev/null; then
        msg_green "DONE!" "Successfully created ${dest}"
    else
        err "Could not backup to ${dest}, did not clean up ${work_dir}"
    fi
}

clean() {

    # If we have not done anything yet, simply exit
    [[ -z "$work_dir" ]] && exit 0

    # If we successfully signed an ISO then suggest to save it before cleaning up
    if [[ -f "$signed_iso" ]]; then
        backup_iso "$signed_iso" || err "Could not back up iso."
    fi

    # If we downloaded and verified an ISO, then suggest to save it before cleaning up
    if (( ! use_local_iso && verified_iso )); then
        if read_yes_no "Save verified (*unsigned*) ISO image?"; then
            backup_iso "$iso" || err "Could not back up verified (unsigned!) iso."
        fi
    fi

    # Then, clean up and exit
    if rm -rf -- "$work_dir"; then
        msg "Removed temporary files, exiting"
        exit 0
    else
        err "Could not remove temporary files"
    fi
}

download_iso() {
    local -a mirrors
    local mirrorlist="/etc/pacman.d/mirrorlist"
    local fallback_mirrors=(
        "https://fastly.mirror.pkgbuild.com"
        "https://geo.mirror.pkgbuild.com"
    )

    # Populate mirrors from local mirrorlist
    if [[ -f "$mirrorlist" ]]; then
        # shellcheck disable=SC2016
        mapfile -t mirrors < <(grep '^Server =' "$mirrorlist" | sed -E 's/^Server = //;s|/\$repo/os/\$arch/?$||')
        if (( ${#mirrors[@]} > 0 )); then
            info "Loaded mirrors from ${mirrorlist}"
        fi
    fi

    # Add fallback mirrors 
    mirrors+=("${fallback_mirrors[@]}")

    (( ${#mirrors[@]} == 0 )) && err "No valid mirrors found!"

    msg "Downloading Arch Linux ${release}..."

    # Try each mirror until one works
    for mirror in "${mirrors[@]}"; do
        local iso_url="${mirror}/iso/${release}/archlinux-${release}-x86_64.iso"
        (( verbose )) && info "Trying mirror" "$mirror"
        if curl --connect-timeout 3 --speed-limit 10240 --output-dir "$work_dir" --progress-bar --remote-name "$iso_url"; then
            msg "Successfully downloaded Arch Linux ISO from ${mirror}"
            iso="${work_dir}/archlinux-${release}-x86_64.iso"
            return 0
        else
            (( verbose )) && info "Failed to download from ${mirror}"
        fi
    done

    err "Failed to download ISO from all mirrors!"
}

verify_iso() {

    if (( offline )); then
        # Try to find sig in same directory, else ask for it
        sig="${iso}.sig"
        if [[ -f "$sig" ]]; then
            msg "Found ${sig} in same directory!"
        else
            ask_path "Arch Linux ISO PGP signature" "sig" "${local_dir}/"
            [[ -f "$sig" ]] || err "${sig} is not a file"
        fi

        # Try to find b2sums in same directory, else ask for it
        b2sums="${local_dir}/b2sums.txt"
        if [[ -f "$b2sums" ]]; then
            msg "Found ${b2sums} in same directory!"
        else
            ask_path "Arch Linux ISO checksums (b2sums.txt)" "b2sums" "${local_dir}/"
            [[ -f "$b2sums" ]] || err "${b2sums} is not a file"
        fi
    else
        remote_sig="https://archlinux.org/iso/${release}/archlinux-${release}-x86_64.iso.sig"
        remote_b2sums="https://archlinux.org/iso/${release}/b2sums.txt"

        curl --silent --output-dir "$work_dir" --progress-bar --remote-name "$remote_sig" || err "Could not download signature!"
        sig="${work_dir}/archlinux-${release}-x86_64.iso.sig"

        curl --silent --output-dir "$work_dir" --progress-bar --remote-name "$remote_b2sums" || err "Could not download b2sums!"
        b2sums="${work_dir}/b2sums.txt"
    fi

    (( verbose )) && {
        info "ISO" "$iso"
        info "sig" "$sig"
        info "b2sums" "$b2sums"
    }

    msg "Verifying ISO..."

    # Checksum
    read -r checksum _ < <(grep -m 1 "archlinux-x86_64.iso" "$b2sums")
    echo "${checksum} ${iso}" | b2sum -c &>/dev/null || err "Checksum verification failed for ${iso}"
    (( verbose )) && info "Checksum verification ok"

    # release signing key
    gpg --keyserver-options auto-key-retrieve --verify "$sig" "$iso" &>/dev/null || err "Signature verification failed!"
    (( verbose )) && info "Signature verification ok"
    
    verified_iso=1
}

select_keys() {
    
    local -a conf_dirs uki_conf_dirs local_keys
    key_path_list=()

    (( verbose )) && msg "Locating keys..."

    # Try to locate existing keys. Maximum 9 items in key_path_list (in local_keys really) or the 'case' code below needs modification.
    # TODO: there 'might' be more than 9 items
    
    # 1. Try user supplied config files
        if [[ -n "$config_file" ]]; then
            (( verbose )) && info "Using config file ${config_file}!"
            load_keycert_conf "$config_file"
        fi

    # 2. Try to find keys provided in regular config files
    conf_dirs+=(
        "${XDG_CONFIG_HOME:-${HOME}/.config}/gsai"
        "/etc/gsai"
    )

    for dir in "${conf_dirs[@]}"; do
        [[ -d "$dir" ]] || continue

        for file in "$dir"/*.conf; do
            [[ -f "$file" ]] || continue
            (( verbose )) && info "Found config file in ${file}!"
            load_keycert_conf "$file"
        done
    done

    # 3. Try to find keys in uki.conf 
    uki_conf_dirs=(
        "/etc/kernel"
        "/run/kernel"
        "/usr/local/lib/kernel"
        "/usr/lib/kernel"
    )

    for dir in "${uki_conf_dirs[@]}"; do
        uki_conf_path="${dir}/uki.conf"
        if [[ -f "$uki_conf_path" ]]; then
            key=$(grep -E '^\s*SecureBootPrivateKey\s*=' "$uki_conf_path" | sed -E 's/^\s*SecureBootPrivateKey\s*=\s*//')
            cert=$(grep -E '^\s*SecureBootCertificate\s*=' "$uki_conf_path" | sed -E 's/^\s*SecureBootCertificate\s*=\s*//')

            if [[ -n "$key" && -n "$cert" ]]; then
                key_path_list+=("${key} ${cert}")
                (( verbose )) && info "Found keys in ${uki_conf_path}!"
            fi
            break  # Use only the first matching uki.conf
        fi
    done

    # 4. Try other common paths
    key_path_list+=(
        "/etc/kernel/secure-boot-private-key.pem /etc/kernel/secure-boot-certificate.pem"
        "/var/lib/sbctl/keys/db/db.key /var/lib/sbctl/keys/db/db.pem"
        "/usr/share/secureboot/keys/db/db.key /usr/share/secureboot/keys/db/db.pem"
        "/etc/efi-keys/DB.key /etc/efi-keys/DB.cer"
        "/etc/kernel/secure-boot.key.pem /etc/kernel/secure-boot.cert.pem"
        "/etc/systemd/secure-boot.key.pem /etc/systemd/secure-boot.cert.pem"
    )

    # Test key pairs
    declare -A seen_pairs  # Associative array for deduplication

    for key_pair in "${key_path_list[@]}"; do
        read -r key cert <<< "$key_pair"
        if [[ -f "$key" && -f "$cert" && -z "${seen_pairs[$key_pair]}" ]]; then
            local_keys+=("$key_pair")
            (( verbose )) && info "Found private key" "$key"
            (( verbose )) && info "Found certificate" "$cert" 
            seen_pairs[$key_pair]=1
        fi
    done

    # Select from local keys
    case "${#local_keys[@]}" in
        0)
            (( verbose )) && info "Could not locate any Secure Boot keys..."
            unset key cert
            ;;
        1)              
            msg "Located the following existing Secure Boot keys:"
            read -r key cert <<< "${local_keys[0]}"

            info "Private key" "$key"
            info "Certificate" "$cert"

            # If autosign is not selected
            if [[ -z "$sign" ]]; then
                read_yes_no "Use these keys to sign the Arch Linux ISO image?" && sign=1
            fi

            if (( sign )); then
                read -r key cert <<< "${local_keys[0]}"
            else
                unset key cert
            fi
            ;;
        *)              
            msg "Located the following existing Secure Boot keys:"
            
            local i nb_keys
            i=1

            for key_pair in "${local_keys[@]}"; do
                read -r key cert <<< "$key_pair"
                info2 "(${i}) Private key" "$key"
                info2 "    Certificate" "$cert"
                ((i++))
            done
            
            nb_keys=$((i - 1))      

            while true; do
                ask "Pick a key (1..${nb_keys}), or press Enter to use another key: "

                case "$answer" in
                    "")  
                        # if the user pressed Enter (cancellation)
                        unset key cert
                        break
                        ;;
                    [1-$nb_keys])
                        ((answer--))  # to be usable as an array index
                        read -r key cert <<< "${local_keys[${answer}]}"
                        (( verbose )) && info "Using key ${key}"
                        (( verbose )) && info "Using cert ${cert}"
                        break
                        ;;
                    *)  
                        msg "Invalid choice. Choose between 1 and ${nb_keys}"
                        ;;
                esac
            done            
            ;;
    esac

    # Select keys manually
    if [[ -z "$key" || -z "$cert" ]]; then

        ask_path "Secure Boot private key" key
        [[ -f "$key" ]] || err "${key} is not a file!"

        ask_path "Secure Boot certificate" cert
        [[ -f "$cert" ]] || err "${cert} is not a file!"

        msg "Selected the following Secure Boot keys"
        info "Private key" "$key"
        info "Certificate" "$cert"
    fi

    # Signing util
    signing_utils=("systemd-sbsign" "/usr/lib/systemd/systemd-sbsign")
    for cmd in "${signing_utils[@]}"; do
        if command_exists "$cmd"; then
            sign_util="$cmd"
            (( verbose )) && info "Will sign with" "$sign_util"        
            break
        fi
    done

    [[ -n "$sign_util" ]] || err "Systemd-sbsign is not available!"
        
    # Check the keys are readable
    if (( EUID )); then  
        if [[ -r "$key" && -r "$cert" ]]; then
            info "Keys are readable! This might be a security risk."
            sign_cmd=("$sign_util")
        elif [[ -n "$sudo_cmd" ]]; then
            (( verbose )) && info "Elevating privileges with ${sudo_cmd}."
            sign_cmd=("$sudo_cmd" "$sign_util")
        else
            (( verbose )) && info "Keys are not readable, trying to elevate privileges."
            
            msg "If requested, enter password to access protected Secure Boot keys."

            # Verify we can use run0
            # Currently run0 requires re-auth for every file...
            min_pk_ver=128

            if command_exists 'pkcheck'; then
                version=$(pkcheck --version 2>/dev/null | awk '{print $NF}')
                if [[ $version =~ ^[0-9]+$ ]] && (( version >= min_pk_ver )); then
                    (( verbose )) && info "Using run0"
                    sudo_cmd=run0
                fi
            fi
            
            # Else try sudo
            if [[ -z "$sudo_cmd" ]]; then

                (( verbose )) && info "Not using run0, polkit too old or version unknown."

                # Verify sudo
                if command_exists 'sudo'; then
                    if sudo -l &>/dev/null; then
                        (( verbose )) && info "Using sudo"
                        sudo_cmd=sudo
                    fi
                fi
            fi

            # Else try doas
            if [[ -z "$sudo_cmd" ]]; then
    
                (( verbose )) && info "Not using 'sudo', not in 'sudoers' or 'sudo' not installed."

                # Verify doas
                if command_exists 'doas'; then
                    sudo_cmd=sudo
                else
                    (( verbose )) && info "Not using 'doas', not installed."
                    err "⚠️  Could not elevate privileges. Try running as root."  
                fi
            fi
            
            sign_cmd=("$sudo_cmd" "$sign_util")
        fi
    else
        info "⚠️  gsai is running as root. Consider running as a normal user."
        sign_cmd=("$sign_util")
    fi
}

require_arg() {
    [[ -n "$1" && "$1" != -* ]] || err "$2"
}

parse_args() {
    
    offline=0
    output_dir=""
    sudo_cmd=""
    use_local_iso=0
    verbose=0
    verify_iso=1

    # Parse command-line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --autosign)
                sign=1
                ;;
            --config)
                shift
                require_arg "$1" "--config requires a configuration file path"
                [[ -f "$1" ]] || err "'$1' is not a valid file"               
                config_file="$1"
                ;;
            --escalate-with)
                shift
                require_arg "$1" "--escalate-with requires one of 'run0', 'sudo', or 'doas'."
                sudo_cmd="$1"
                [[ "$sudo_cmd" == 'run0' || "$sudo_cmd" == 'sudo' || "$sudo_cmd" == 'doas' ]] || err "${sudo_cmd} is not a valid escalation command"
                ;;
            -h | --help)
                usage
                exit 0
                ;;
            --iso)
                shift
                require_arg "$1" "--iso requires a file path"
                [[ -f "$1" ]] || err "'$1' is not a valid file"
                iso="$1"
                use_local_iso=1
                ;;
            --offline)
                offline=1
                ;;
            --output-dir)
                shift
                require_arg "$1" "--output-dir requires a path"
                [[ -d "$1" && -w "$1" ]] || err "'$1' is not a writable directory"
                output_dir="${1%/}"
                ;;         
            --skip-iso-verification)
                verify_iso=0
                ;;
            -v | --verbose)
                verbose=1
                ;;
            *)
                usage
                err "Unknown option: $1"
                ;;
        esac
        shift
    done
}

usage() {
    cat <<EOF
version: ${version}
  Options:
       --autosign                Automatically sign if only one set of Secure Boot signing keys is found
       --config                  Specify a configuration file
       --escalate-with           Takes one of 'run0' 'sudo' or 'doas'
   -h, --help                    Won't help you much
       --iso                     Specify an Arch Linux ISO image file
       --offline                 Prompt for the paths of necessary files instead of fetching them online
       --output-dir              Output directory for signed iso
       --skip-iso-verification   Do not check iso integrity
   -v, --verbose                 Verbose output
EOF
}

# ----------------------------------------------------------------------------------------
# Script
# ----------------------------------------------------------------------------------------

debug=1
# Default library directory (installed location)
: "${GSAI_LIBDIR:=/usr/lib/gsai}"

if [[ -r "$GSAI_LIBDIR/gsai_utils.sh" ]]; then
    # Installed mode
    # shellcheck source=/usr/lib/gsai/gsai_utils.sh
    source "$GSAI_LIBDIR/gsai_utils.sh"
    (( debug )) && info "sourced ${GSAI_LIBDIR}/gsai_utils.sh"
else
    # Development mode (git clone)
    SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
    # shellcheck source=../lib/gsai_utils.sh
    source "${SCRIPT_DIR}/../lib/gsai_utils.sh"
    (( debug )) && info "${SCRIPT_DIR}/../lib/gsai_utils.sh"
fi

# Enable colors
if [[ -t 2 && -n "$COLORTERM" ]]; then
    if [[ -n "$NO_COLOR" ]]; then
        (( verbose )) && info "Colors disabled by '$NO_COLOR'. See https://no-color.org/" 
    else 
        enable_colors
    fi
fi

msg_green "gsai" "Sign Arch Linux ISOs for Secure Boot"

# Parse arguments
parse_args "$@"

# Check for needed commands
command_exists 'mcopy' || err "Package 'mtools' is required"
command_exists 'xorriso' || err "Package 'libisoburn' is required"

# Create working directory
work_dir=$(mktemp -d --tmpdir ARCH_ISO.XXX || err "Could not create temporary directory!")
(( verbose )) && info "Work directory:" "$work_dir"

if (( offline )); then

    # Use the iso if provided via commandline, else ask for it
    [[ -n "$iso" ]] || ask_path "Arch Linux ISO" "iso"

    # Store local directory name to look for sigs/bsums
    local_dir="$(dirname "$iso")"
    
    release=$(basename "$iso" | grep -oP  -m 1 '\b\d{4}\.\d{2}\.\d{2}\b') || err "Could not determine current release from iso filename!"

else
    release=$(curl --silent "$download_page" 2>&1 | grep -o -m 1 '[0-9]\{4\}\.[0-9]\{2\}\.[0-9]\{2\}' || err "Could not determine current release!")
    
    # Download unless provided with --iso
    if ! (( use_local_iso )); then

        # Suggest to download with bittorrent
        magnet_link=$(curl -s "$download_page" 2>/dev/null | grep -o -m 1 'magnet:[^"]*')
        if [[ -n "$magnet_link" ]]; then
            msg "Consider downloading the ISO image via bittorrent. Press 'q' to quit, then run 'gsai --iso <iso_path>':"
            info "$magnet_link"
        
            ask "Press any other key to continue instead. "
            [[ "$answer" == "q" ]] && exit 0
        else
            (( verbose )) && info "Could not get magnet link!"
        fi

        download_iso
    fi
fi

if (( verify_iso )); then
    verify_iso
else
    verified_iso=0
fi

select_keys

msg "Configuring Arch Linux ISO image..."

## First extract the relevant files and El Torito boot images:
(( verbose )) && info "Running osirrox to extract files..."

osirrox -indev "$iso" \
    -extract_boot_images "$work_dir" \
    -cpx /arch/boot/x86_64/vmlinuz-linux \
        /EFI/BOOT/BOOTx64.EFI \
        /EFI/BOOT/BOOTIA32.EFI \
        /shellx64.efi \
        /shellia32.efi "$work_dir" &>/dev/null || err "Could not run osirrox command!"

# Sign all extracted files
files=(BOOTx64.EFI BOOTIA32.EFI shellx64.efi shellia32.efi vmlinuz-linux)

for file in "${files[@]}"; do
    chmod +w "${work_dir}/${file}" || err "Could not make boot files writable!"
    "${sign_cmd[@]}" --private-key "$key" --certificate "$cert" sign "${work_dir}/${file}" --output "${work_dir}/${file}" &>/dev/null || err "Could not sign ${file}!"
    (( verbose )) && info "Signed" "$file"
done

## Repack
mcopy -D oO -i "${work_dir}/eltorito_img2_uefi.img" "${work_dir}/vmlinuz-linux" ::/arch/boot/x86_64/vmlinuz-linux || err "Could not run mcopy command!"
mcopy -D oO -i "${work_dir}/eltorito_img2_uefi.img" "${work_dir}/BOOTx64.EFI" "${work_dir}/BOOTIA32.EFI" ::/EFI/BOOT/ || err "Could not run mcopy command!"
mcopy -D oO -i "${work_dir}/eltorito_img2_uefi.img" "${work_dir}/shellx64.efi" "${work_dir}/shellia32.efi" ::/ || err "Could not run mcopy command!"
(( verbose )) && info "Ran mcopy commands"

signed_iso="${work_dir}/archlinux-${release}-x86_64-signed.iso"

(( verbose )) && info "Running xorriso to repack"
xorriso -indev "$iso" \
    -outdev "$signed_iso" \
    -map "${work_dir}/vmlinuz-linux" /arch/boot/x86_64/vmlinuz-linux \
    -map_l "${work_dir}/" /EFI/BOOT/ "${work_dir}/BOOTx64.EFI" "${work_dir}/BOOTIA32.EFI" -- \
    -map_l "${work_dir}/" / "${work_dir}/shellx64.efi" "${work_dir}/shellia32.efi" -- \
    -boot_image any replay \
    -append_partition 2 0xef "${work_dir}/eltorito_img2_uefi.img" &>/dev/null || err "Could not repack with xorriso!"

(( verbose )) && info "Successfully created signed ISO: $(basename "$signed_iso")"
